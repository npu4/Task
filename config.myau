%scaner_name tscaner
%codes_type codes  

%ident_name Id
%idents {[:Letter:]|[:letter:]|_}{[:Letter:]|[:letter:]|_|[:digits:]}

%class_members
"__int128 integer_part;
__int128 fractional_part;
size_t exponent;
ssize_t exp_sign;
size_t frac_part_num_digits;
bool is_float;
char32_t precision;
char32_t char32_code;
__float128 build_float();"


%token_fields
"unsigned __int128 int_val; __float128 float_val;"


%codes
module,
import,     export,
var,        type,       array,
long,       short,
int,        float,      uint,       bool,       char,       string,
void,       byte,
int8_t,     int16_t,    int32_t,    int64_t,    int128_t,
uint8_t,    uint16_t,   uint32_t,   uint64_t,   uint128_t,
float32_t,  float64_t,  float128_t,
bool8_t,    bool16_t,   bool32_t,   bool64_t,
char8_t,    char16_t,   char32_t,   string8_t,  string16_t, string32_t,
fn,         val,        ref,        const_ref,  enum,
struct,
const,
true,       false,
if,         then,       elif,       else,       endif,
for,        while,      repeat,     until,      
break,      continue,   return,
read,       print,      match,

Comma,                  Semicolon,             
Colon,                  Dot,                
Open_round_bracket,     Closed_round_bracket,
Open_square_bracket,    Closed_square_bracket, 
Equal_sign,             At_sign,             
Tuple_begin,            Tuple_end,
Variant_delimiter,      Conditional_op,        
Logical_or,             Logical_or_not,      
Logical_xor,            Logical_xor_not,
Logical_and,            Logical_and_not,
Logical_not,            Less_than,
Greater_than,           Lower_or_equals,
Greater_or_equals,      Not_equals,
Bitwise_xor,            Bitwise_or,
Bitwise_xor_not,        Bitwise_or_not,
Open_curly_bracket,     Closed_curly_bracket,
Bitwise_and,            Bitwise_and_not,
Left_shift,             Right_shift,
Signed_right_shift,     Bitwise_not,
Plus,                   Minus,
Mul,                    Div,
Fdiv,                   Mod,
Power,                  Fpower,
Sizeof,                 Dimension_size,
Allocated_array_open,   Allocated_array_close,
 Module_name_prefix,    Scope_resolution,
Assign_to_field,        Label_prefix,
Label_suffix,           Assign,
Pattern_is,             Br_dots


%impl_additions "
#include <quadmath> 
size_t digit2int(char32_t ch)
{
size_t v =  ch - U'0';
return (v<=9)? v:(v&0b1101'1111) - 7;
};
__float128 myfirstscaner::build_float()
{
__float128 num;                                                                               
num = int_value + fract_part*powq(10, num_of_digits);
num = num*powq(10, sign_of_degree*exponent);
return num;}"


%keywords
"module" : module,
"import" : import,      "export" : export,
"var" : var,
"type" : type,
"array" : array,
"long" : long,              "short" : short,
"int" : int,                "float" : float,            "uint" : uint,
"bool" : bool,              "char" : char,              "string" : string,
"void" : void,              "byte" : byte,
"int8_t" : int8_t,          "int16_t" : int16_t,        "int32_t" : int32_t,
"int64_t" : int64_t,        "int128_t" : int128_t,
"uint8_t" : uint8_t,        "uint16_t" : uint16_t,      "uint32_t" : uint32_t,
"uint64_t" : uint64_t,      "uint128_t" : uint128_t,
"float32_t" : float32_t,    "float64_t" : float64_t,
"float128_t" : float128_t,  
"bool8_t" : bool8_t,        "bool16_t" : bool16_t,  
"bool32_t" : bool32_t,      "bool64_t" : bool64_t,
"char8_t" : char8_t,        "char16_t" : char16_t,      "char32_t" : char32_t,
"string8_t" : string8_t,    "string16_t" : string16_t,  "string32_t" : string32_t,
"fn" : fn,
"val" : val,
"ref" : ref,
"const ref" : const_ref,
"enum" : enum,
"struct" : struct,
"const" : const,
"true" : true,              "false" : false,
"if" : if,                  "then" : then,
"elif" : elif,              "else" : else,
"endif" : endif,
"for" : for,                "while" : while,
"repeat" : repeat,          "until" : until,
"break" : break,            "continue" : continue,
"return" : return,
"read" : read,              "print" : print,
"match" : match


%delimiters
","     : Comma,                ";"     : Semicolon,             
":"     : Colon,                "."     : Dot,                
"("     : Open_round_bracket,   ")"     : Closed_round_bracket,
"["     : Open_square_bracket,  "]"     : Closed_square_bracket, 
"="     : Equal_sign,           "@"     : At_sign,             
"(:"    : Tuple_begin,          ":)"    : Tuple_end,
".|."   : Variant_delimiter,    "?"     : Conditional_op,        
"||"    : Logical_or,           "!||"   : Logical_or_not,      
"^^"    : Logical_xor,          "!^^"   : Logical_xor_not,
"&&"    : Logical_and,          "!&&"   : Logical_and_not,
"!"     : Logical_not,          "<"     : Less_than,
">"     : Greater_than,         "<="    : Lower_or_equals,
">="    : Greater_or_equals,    "!="    : Not_equals,
"^"     : Bitwise_xor,          "|"     : Bitwise_or,
"~^"    : Bitwise_xor_not,      "~|"    : Bitwise_or_not,
"{"     : Open_curly_bracket,   "}"     : Closed_curly_bracket,
"&"     : Bitwise_and,          "~&"    : Bitwise_and_not,
"<<"    : Left_shift,           ">>"    : Right_shift,
">>>"   : Signed_right_shift,   "~"     : Bitwise_not,
"+"     : Plus,                 "-"     : Minus,
"*"     : Mul,                  "/"     : Div,
"/."    : Fdiv,                 "%"     : Mod,
"**"    : Power,                "**."   : Fpower,
"#"     : Sizeof,               "##"    : Dimension_size,
"[:"    : Allocated_array_open, ":]"    : Allocated_array_close,
"|:"    : Module_name_prefix,   "::"    : Scope_resolution,
"<-"    : Assign_to_field,      "<:"    : Label_prefix,
":>"    : Label_suffix,         ":="    : Assign,
"->"    : Pattern_is,
"{..}"  : Br_dots


%impl_additions "
  #include <quadmath>

  size_t digit2int(char32_t ch) {
    size_t v = ch - U'0';
    return (v<=9)? v : (v&0b1101'1111) - 7;
  }
  __int128 setexp(char32_t ch) {
    return (ch == '-')? -1 : 1;
  }

  __float128 Scaner::build_float(){
    return integer_part + fractional_part*powq(10,-frac_part_num_digits)+exp_sign*exponent;
  }

  Lexem_code precision2code(char32_t ch){
    switch (ch) {
      case U'S': case U's':
        return Float32;
        break;
      case U'D': case U'd':
        return Float64;
        break;
      case U'E': case U'e':
        return Float80;
        break;
      case U'Q': case U'q':
        return Float128;
        break;
      default:
        return Float32;
        break;
    }
  }
"


%strings "buffer.clear();":"token.code=(buffer.length()==1)?Char:String;"

%action write_by_code "buffer += char_code;"
%action add_dec_digit_to_char_code "char_code = char_code * 10 + digit2int(ch);"
%action add_oct_digit_to_char_code "char_code = char_code * 8 + digit2int(ch);"
%action add_bin_digit_to_char_code "char_code = char_code * 2 + digit2int(ch);"
%action add_hex_digit_to_char_code "char_code = char_code * 16 + digit2int(ch);"
{
(\$([:digits:]$add_dec_digit_to_char_code('?[:digits:]$add_dec_digit_to_char_code)*|
   0o[:odigits:]$add_oct_digit_to_char_code('?[:odigits:]$add_oct_digit_to_char_code)*|
0(b|B)[:bdigits:]$add_bin_digit_to_char_code('?[:bdigits:]$add_bin_digit_to_char_code)*|
0(x|X)[:xdigits:]$add_hex_digit_to_char_code('?[:xdigits:]$add_hex_digit_to_char_code)*)$write_by_code)*|
("([:ndq:]$write|""$write)*"(\$([:digits:]$add_dec_digit_to_char_code('?[:digits:]$add_dec_digit_to_char_code)*|
   0o[:odigits:]$add_oct_digit_to_char_code('?[:odigits:]$add_oct_digit_to_char_code)*|
0(b|B)[:bdigits:]$add_bin_digit_to_char_code('?[:bdigits:]$add_bin_digit_to_char_code)*|
0(x|X)[:xdigits:]$add_hex_digit_to_char_code('?[:xdigits:]$add_hex_digit_to_char_code)*)$write_by_code)+)*
} 


%numbers "int_val = 0;
          float_val = 0;
          is_float = false;
          integer_part = 0;
          fractional_part = 0;
          exponent = 1;
          exp_sign = 1;
          frac_part_num_digits = 0;
          token.code = Integer;"
          :
          "
          if(is_float){
            token.float_val=build_float();
            token.code = precision2code(precision);
          } else {
            token.int_val=integer_part;
            token.code = Integer;
          }"	
          %action addHexDigit "integer_part = (integer_part << 4) + digit2int(ch);"
          %action addDecDigit "integer_part = integer_part * 10 + digit2int(ch);"
          %action addBinDigit "integer_part = (integer_part << 1) + digit2int(ch);"
          %action addOctDigit "integer_part = (integer_part << 3) + digit2int(ch);"
          %action setIsFloat "is_float = true;"
          %action addDigitToDegree "exponent = exponent * 10 + digit2int(ch);"
          %action addDecToFrac "fractional_part = fractional_part / 10 + digit2int(ch); frac_part_num_digits += 1;"
          %action setExpSign "exp_sign = setexp(ch);"
          %action setPrecision "precision = ch; is_float = true;"
	                                
{[:digits:]$addDecDigit('?[:digits:]$addDecDigit)*(.$setIsFloat[:digits:]$addDecToFrac('?[:digits:]$addDecToFrac*))
?(((S|s)|(D|d)|(E|e)|(Q|q))$setPrecision+|-$setExpSign?[:digits:]$addDigitToDegree('?[:digits:]$addDigitToDegree)*)?|
0o[:odigits:]$addOctDigit('?[:odigits:]$addOctDigit)*|
0(b|B)[:bdigits:]$addBinDigit('?[:bdigits:]$addBinDigit)*|
0(x|X)[:xdigits:]$addHexDigit('?[:xdigits:]$addHexDigit)*}
