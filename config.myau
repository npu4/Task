%scaner_name tscaner
%codes_type codes  

%ident_name Id
%idents {[:Letter:]|[:letter:]|_}{[:Letter:]|[:letter:]|_|[:digits:]}

%class_members
"__int128 integer_part;
__int128 fractional_part;
size_t exponent;
ssize_t exp_sign;
size_t frac_part_num_digits;
bool is_float;
char32_t precision;
char32_t char32_code;
__float128 build_float();"


%token_fields
"unsigned __int128 int_val; __float128 float_val;"


%codes
module,
import,     export,
var,        type,       array,
long,       short,
int,        float,      uint,       bool,       char,       string,
void,       byte,
int8_t,     int16_t,    int32_t,    int64_t,    int128_t,
uint8_t,    uint16_t,   uint32_t,   uint64_t,   uint128_t,
float32_t,  float64_t,  float128_t,
bool8_t,    bool16_t,   bool32_t,   bool64_t,
char8_t,    char16_t,   char32_t,   string8_t,  string16_t, string32_t,
fn,         val,        ref,        const ref,  enum,
struct,
const,
true,       false,
if,         then,       elif,       else,       endif,
for,        while,      repeat,     until,      
break,      continue,   return,
read,       print,      match,
semicolon,  colon,
equal,      not_equal,
open_square_bracket,        close_square_bracket,
open_square_bracket_colon,  close_square_bracket_colon,
open_figure_bracket,        close_figure_bracket,
open_round_bracket,         close_round_bracket,
open_round_bracket_colon,   close_round_bracket_colon,

scope_resolution,
question_mark,
logical_not,    
logical_or,     not_logical_or,
logical_xor,    not_logical_xor,
logical_and,    not_logical_and,
less,           greater,    
less_or_equal,  greater_or_equal,
not,
or,     not_or, 
xor,    not_xor,
and,    not_and,
lshift, rshift,

plus,           minus,      
multiplication, division,   
mod,

comma,
assignment,
structure_dereference



%impl_additions "
#include <quadmath> 
size_t digit2int(char32_t ch)
{
size_t v =  ch - U'0';
return (v<=9)? v:(v&0b1101'1111) - 7;
};
__float128 myfirstscaner::build_float()
{
__float128 num;                                                                               
num = int_value + fract_part*powq(10, num_of_digits);
num = num*powq(10, sign_of_degree*exponent);
return num;}"


%keywords
"module" : module,
"import" : import,      "export" : export,
"var" : var,
"type" : type,
"array" : array,
"long" : long,              "short" : short,
"int" : int,                "float" : float,            "uint" : uint,
"bool" : bool,              "char" : char,              "string" : string,
"void" : void,              "byte" : byte,
"int8_t" : int8_t,          "int16_t" : int16_t,        "int32_t" : int32_t,
"int64_t" : int64_t,        "int128_t" : int128_t,
"uint8_t" : uint8_t,        "uint16_t" : uint16_t,      "uint32_t" : uint32_t,
"uint64_t" : uint64_t,      "uint128_t" : uint128_t,
"float32_t" : float32_t,    "float64_t" : float64_t,
"float128_t" : float128_t,  
"bool8_t" : bool8_t,        "bool16_t" : bool16_t,  
"bool32_t" : bool32_t,      "bool64_t" : bool64_t,
"char8_t" : char8_t,        "char16_t" : char16_t,      "char32_t" : char32_t,
"string8_t" : string8_t,    "string16_t" : string16_t,  "string32_t" : string32_t,
"fn" : fn,
"val" : val,
"ref" : ref,
"const ref" : const ref,
"enum" : enum,
"struct" : struct,
"const" : const,
"true" : true,              "false" : false,
"if" : if,                  "then" : then,
"elif" : elif,              "else" : else,
"endif" : endif,
"for" : for,                "while" : while,
"repeat" : repeat,          "until" : until,
"break" : break,            "continue" : continue,
"return" : return,
"read" : read,              "print" : print,
"match" : match


%delimiters
";" : semicolon,                    ":" : colon,   
"=" : equal,                        "!=" : not_equal,
"[" : open_square_bracket,          "]" : close_square_bracket,
"[:" : open_square_bracket_colon,   ":]" : close_square_bracket_colon,
"{" : open_figure_bracket,          "}": close_figure_bracket,
"(" : open_round_bracket,           ")": close_round_bracket,
"(:" : open_round_bracket_colon,    ":)" : close_round_bracket_colon,
"::" : scope_resolution,
"?" : question_mark,
"!" : logical_not,
"||" : logical_or,          "!||" : not_logical_or,
"^^" : logical_xor,         "!^^" : not_logical_xor,
"&&" : logical_and,         "!&&" : not_logical_and,
"<" : less,                 ">" : greater,
"<=" : less_or_equal,       ">=" : greater_or_equal,
"~" : not,
"|" : or,       "~|" : not_or,
"^" : xor,      "~^" : not_xor,
"&" : and,      "~&" : not_and,
"<<" : lshift,  ">>" : rshift,
">>>" : ,
"+" : plus,     "-" : minus,
"*" : multiplication,
"/" : division,
"%" : mod,
"/." : ,
"**" : ,
"**." : ,
"#" : ,
"##" : ,
"," : comma,
":=" : assignment,
"->" : structure_dereference 



%strings "buffer.clear();":"token.code=(buffer.length()==1)?Char:String;"

%action write_by_code "buffer += char_code;"
%action add_dec_digit_to_char_code "char_code = char_code * 10 + digit2int(ch);"
%action add_oct_digit_to_char_code "char_code = char_code * 8 + digit2int(ch);"
%action add_bin_digit_to_char_code "char_code = char_code * 2 + digit2int(ch);"
%action add_hex_digit_to_char_code "char_code = char_code * 16 + digit2int(ch);"

{
(\$([:digits:]$add_dec_digit_to_char_code('?[:digits:]$add_dec_digit_to_char_code)*|
   0o[:odigits:]$add_oct_digit_to_char_code('?[:odigits:]$add_oct_digit_to_char_code)*|
0(b|B)[:bdigits:]$add_bin_digit_to_char_code('?[:bdigits:]$add_bin_digit_to_char_code)*|
0(x|X)[:xdigits:]$add_hex_digit_to_char_code('?[:xdigits:]$add_hex_digit_to_char_code)*)$write_by_code)*|
("([:ndq:]$write|""$write)*"(\$([:digits:]$add_dec_digit_to_char_code('?[:digits:]$add_dec_digit_to_char_code)*|
   0o[:odigits:]$add_oct_digit_to_char_code('?[:odigits:]$add_oct_digit_to_char_code)*|
0(b|B)[:bdigits:]$add_bin_digit_to_char_code('?[:bdigits:]$add_bin_digit_to_char_code)*|
0(x|X)[:xdigits:]$add_hex_digit_to_char_code('?[:xdigits:]$add_hex_digit_to_char_code)*)$write_by_code)+)*

} 


%numbers "int_val = 0;
          float_val = 0;
          is_float = false;
          integer_part = 0;
          fractional_part = 0;
          exponent = 1;
          exp_sign = 1;
          frac_part_num_digits = 0;
          token.code = Integer;"
          :
          "
          if(is_float){
            token.float_val=build_float();
            token.code = precision2code(precision);
          } else {
            token.int_val=integer_part;
            token.code = Integer;
          }"	
          %action addHexDigit "integer_part = (integer_part << 4) + digit2int(ch);"
          %action addDecDigit "integer_part = integer_part * 10 + digit2int(ch);"
          %action addBinDigit "integer_part = (integer_part << 1) + digit2int(ch);"
          %action addOctDigit "integer_part = (integer_part << 3) + digit2int(ch);"
          %action setIsFloat "is_float = true;"
          %action addDigitToDegree "exponent = exponent * 10 + digit2int(ch);"
          %action addDecToFrac "fractional_part = fractional_part / 10 + digit2int(ch); frac_part_num_digits += 1;"
          %action setExpSign "exp_sign = setexp(ch);"
          %action setPrecision "precision = ch; is_float = true;"
	                                
{[:digits:]$addDecDigit('?[:digits:]$addDecDigit)*(.$setIsFloat[:digits:]$addDecToFrac('?[:digits:]$addDecToFrac*))
?(((S|s)|(D|d)|(E|e)|(Q|q))$setPrecision+|-$setExpSign?[:digits:]$addDigitToDegree('?[:digits:]$addDigitToDegree)*)?|
0o[:odigits:]$addOctDigit('?[:odigits:]$addOctDigit)*|
0(b|B)[:bdigits:]$addBinDigit('?[:bdigits:]$addBinDigit)*|
0(x|X)[:xdigits:]$addHexDigit('?[:xdigits:]$addHexDigit)*}
